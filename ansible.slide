Ansible - who needs another automation framework?
short introduction to the concepts of the python based automation framework ANSIBLE
29 Apr 2014
Tags: ansible, devops

Andreas Pohle, Cornelius Keller, Teymour Taghavi
from the Bettermarks Devops Team
bmdevops@bettermarks.de
http://www.bettermarks.com
@bettermarks

* Agenda

Motivation

- Why 
- Features

* Easy to get Started

.play virtualenv.sh /begin/,/end/

Takes about 30 Seconds, and we are ready to go.

See [[http://docs.ansible.com/intro_installation.html]]

* Thats all? Really?

Yes, we did setup an usable ansible evnironment with the two primary ansible commands available:

- *ansible* for ad hoc automation
- *ansible-playbook* to execute playbooks ( more on playbooks later) 

So we are ready To explore The first cool Feature of Ansible, ad-hoc automation.

* Ad-Hoc Automation with ansible

.play simple_adhoc.sh /begin/,/end/

We just executed the simplest possible ansible module *ping* on our local machine.
We will learn more about ansible modules in a few minutes.

* Modules

- scripts with a very simple interface, can be written in any language
- are called with the parameters as key=value pairs 
- return json 
- are idempotent, i.e. do noting if the desired target state is already there.




For most use cases there are already modules included in anslible, but it is easy to write your ownes.
See [[http://docs.ansible.com/modules_by_category.html]] for a list of included modules.

* More Ad-Hoc examples with modules

Gathering Facts

.play gathering_facts.sh /begin/,/end/

Check out the ansible source code into /tmp

# TODO ansible is to big, takes to long in presentation mode :(

.play git_checkout.sh /begin/,/end/

Delete it again

.play delete_checkout.sh /begin/,/end/

Stop apache running at [[http://localhost/]]:

.play stop_apache.sh /begin/,/end/

Start it again

.play start_apache.sh /begin/,/end/


* Inventory

.code hosts

Ansibles default inventories are files in .ini format. A section corresponds to a host group, in this case *demo*. In this case the four members of demo are obviously the local machine.
An Inventory can contain much more then the hostnames. You also can provide variables for hosts or groups in an combination of .ini .yaml files.

* Ad-Hoc with inventory

First export inventory location ( defaults to /etc/anslible/hosts )

.code simple_adhoc_with_inventory.sh /inventory/,/end/

Now we can use the demo group definded in the inventory with ansible

.play simple_adhoc_with_inventory.sh /begin/,/end/

Ansible will execute the ping module in parallel on all machines matching *demo*.
You can chung this to n machine chungs with the parameter -f n or --forks=n.


* But .ini files do not scale

If you have to manage , lets say, 700 vms in two data centers .ini and .yaml files will not scale.


* dynamic inventories

Ansible can read dynamic inventories as an output of an scirpt. So you can plug in your own inventory. 
Bettermarks has a custom invetory backed by spacewalk, as there whre no spacewalk inventory provided when we started using ansible.
Right now there prepackaged scripts for the following environments: 

  Amazon EC2
  BSD Jails
  Digital Ocean
  Google Compute Engine
  Linode
  OpenShift
  OpenStack Nova
  Red Hat's SpaceWalk
  Vagrant (not to be confused with the provisioner in vagrant, which is preferred)
  Zabbix


see [[http://docs.ansible.com/intro_dynamic_inventory.html]] for more information on dynamic inventories.

* Playbooks

Playbooks are a simple but powerful way to do your system automation build on top of inventories and modules.
A playbooks can be used to provision a single machine or orchestrate a set of machines or even an entire cluster.

- Playbooks are human readable, written in YAML.
- Describe the desired state of your infrastructure.

In the following slides we will learn a little bit of theory on the playbook language and continue with some practical examples later.

* Anatomy of a Playbook

A playbook can contaion multiple plays.
Each play is made of:

- A Header section defining Hosts, Users and opitonal Variables
- A Tasks section defining the actual tasks to be executed
- A Handlers section containing handlers to be notified by the tasks.

* Play Header  Hosts and Users and Roles


 ---
 - hosts: webservers # pattern to match inventory
   remote_user: remote_user # user used by the ssh connection
   sudo: yes # use sudo
   sudo_user: # sudo as user
   roles:
      - role1
      - role2


- remote_user is the user used by ssh. 
- if sudo: yes is used, the remote user must have sudo privileges.
- sudo_user: execute as the user via sodo.
- User can be set on task level using the same syntax.
- Roles are reusable playbooks distributed in a defined folder structure ( more on roles later).

* Tasks 

- is defined by a name and a module definition

 tasks:
 - name: make sure apache is running
   service: name=httpd state=running

- can ignore rerros, otherwise the execution of the playbook will stop on error

 ignore_errors: True

- can notify handlers defined in the handlers section.

 notify:
     - restart memcached
     - restart apache

* Handlers

 handlers:
    - name: restart memcached
      service:  name=memcached state=restarted
    - name: restart apache
      service: name=apache state=restarted

The handlers are defied in the thame way as tasks but in the handlers section. Handlers are only executed if the module called by a task actualy changed something.


* Variables 

* Loops

* Conditions


# TODO describe Variables.



* Agenda

Practical Examples

- Jenkins integration
- Live Deployment

