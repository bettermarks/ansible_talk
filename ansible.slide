Ansible - Who Needs Another Automation Framework?
Introduction to the concepts of the Python-based automation framework Ansible

29 April 2014
Tags: ansible, devops

Andreas Pohle (@apoh), Cornelius Keller, Teymour Taghavi

bettermarks DevOps
bmdevops@bettermarks.de

http://www.bettermarks.com
@bettermarks

* Agenda

Motivation

- Why
- Features

* Easy to get Started

.play virtualenv.sh /begin/,/end/

Takes about 30 seconds and we are ready to go.

See [[http://docs.ansible.com/intro_installation.html]]

* That's all? Really?

Yes, we did setup a usable ansible environment with the two primary ansible commands available:

- *ansible* for ad hoc automation
- *ansible-playbook* to execute playbooks (more on playbooks later)

So we are ready to explore The first cool Feature of Ansible, ad-hoc automation.

* Ad-Hoc automation with ansible

.play simple_adhoc.sh /begin/,/end/

We just executed the simplest possible ansible module *ping* on our local machine.
We will learn more about ansible modules in a few minutes.

* Modules

- scripts with a very simple interface, can be written in any language
- are called with the parameters as key=value pairs
- return json
- are idempotent, i.e. do noting if the desired target state is already there.

For most use cases there are already modules included in ansible, but it is easy to write your own modules.

*
.image images/ansible_modules.png

[[http://docs.ansible.com/modules_by_category.html]]

* More Ad-Hoc examples with modules

Gathering facts

.play gathering_facts.sh /begin/,/end/

Check out the ansible source code into /tmp

# TODO ansible is to big, takes to long in presentation mode :(

.play git_checkout.sh /begin/,/end/

Delete it again

.play delete_checkout.sh /begin/,/end/

Stop apache running at [[http://localhost/]]:

.play stop_apache.sh /begin/,/end/

Start it again

.play start_apache.sh /begin/,/end/

* Inventory

.code hosts

Ansible's default inventories are files in .ini format. A section corresponds to a host group, in this case *demo*. In this case the four members of demo are obviously the local machine.

An inventory can contain much more then the hostnames. You can also provide variables for hosts or groups in a combination of .ini and .yaml files.

* Ad-Hoc with inventory

First export inventory location (defaults to /etc/anslible/hosts)

.code simple_adhoc_with_inventory.sh /inventory/,/end/

Now we can use the demo group definded in the inventory with ansible

.play simple_adhoc_with_inventory.sh /begin/,/end/

Ansible will execute the ping module in parallel on all machines matching *demo*. You can limit the number of parallel deployments with parameter -f n or --forks=n.

* But .ini files do not scale

If you have to manage , lets say, 700 vms in two data centers .ini and .yaml files will not scale.

* Dynamic inventories

Ansible can read dynamic inventories as an output of a script. So you can plug in your own inventory.

Currently ansible comes with scripts that support following inventory sources (found in the plugins/ folder)

  Amazon EC2
  Cobbler
  BSD Jails
  Digital Ocean
  Google Compute Engine
  Linode
  OpenShift
  OpenStack Nova
  Red Hat's SpaceWalk
  Vagrant (not to be confused with the provisioner in vagrant, which is preferred)
  Zabbix

#Note that at the time when bettermarks started with ansible there was no SpaceWalk script, so we had to write our own script.

see [[http://docs.ansible.com/intro_dynamic_inventory.html]] for more information on dynamic inventories.

* Playbooks

"If Ansible modules are the tools in your workshop, playbooks are your design plans."

Simply put, playbooks are a collection of ansible actions. Additionaly, they provide tools to control the flow of those actions.

A playbook can be used to provision a single machine, orchestrate a set of machines or even an entire cluster.

- Playbooks are human readable, written in YAML.
- Describe the desired state of your infrastructure.

* Anatomy of a Playbook

A playbook consists of one or more *plays*.

Each play has:

- a header section defining hosts and optional variables
- a task section defining the actual tasks to be executed
- an optional handler section containing callbacks to be notified by the tasks.

* Example playbook

.code playbooks/playbook1.yml
.play playbooks/playbook1.sh /begin/,/end/

- each play gathers information about the target hosts before running
- a failed task stops and exits the playbook

* Play Header: Hosts, users and roles

 ---
 - name: Play 1             # Play description
   hosts: demo              # can be either a host or a group of hosts (from the inventory)
   remote_user: user_1      # user used by the ssh connection
   sudo: yes                # execute modules as sudo
   sudo_user: user_2        # sudo user
   roles:                   # roles for the play (more on roles later)
      - role1
      - role2

- the remote_user and sudo_user can be set from outside the playbook with:

  ansible-playbook playbook_file.yml --user user_3 --sudo-user user_4

- users set in the playbook always win

  playbook users > command line users > defaults

- users can be set on task level using the same syntax.

* Tasks

- is defined by a name, a module and a key/value pair

 tasks:
   - name: make sure apache is running
     service: name=httpd state=running

- can ignore errors, otherwise the execution of the playbook will stop on error

 ignore_errors: True

.play playbooks/playbook2.sh /begin/,/end/

- after execution, come back with either of the following states: "ok", "changed" or "failed"

* Handlers

- handlers are defined in the same way as tasks but in the handlers section.
- handlers are only executed if the calling task comes back with the "changed" state

.code playbooks/playbook3.yml
.play playbooks/playbook3.sh /begin/,/end/

.play playbooks/delete_tmp_config.sh /begin/,/end/

* Variables

- can have different origins (playbook, inventory, command line)
- can be a single value, a list or a hashmap/dictionary
- can be recognized by double brackets: {{var_name}}
- support the jinja2 filters system:

  {{var_name}} => /path/to/filename.txt
  {{var_name|basename}} =>  filename.txt

- see [[http://jinja.pocoo.org/docs/templates/#builtin-filters]] for a list of filters


* Variable origins

- defined or included in the playbook (play header):

    vars:
      tmp_dir: /tmp

    vars_file:
      - "vars/common.yml"

- the inventory:

  [demo:vars]
  timeout=30

- the command line:

  ansible-playbook playbook_file.yml -e "var1=value1 var2=value2"

- any variable gathered from the setup module:

.play gathering_facts.sh /begin/,/end/

* Variables example

.code playbooks/playbook4.yml
.play playbooks/playbook4.sh /begin/,/end/

* Loops

* Standard  Loop Example

 - name: add several users
   user: name={{ item }} state=present groups=wheel
   with_items:
      - testuser1
      - testuser2

with_items: can refer to list defined in the vars section, in a variables file or the inventory.

 with_items: somelist

* More Loops

See  [[http://docs.ansible.com/playbooks_loops.html]] for more complex loop examples including:

- Nested loops
- Loops over hashes
- Loops over fileglobs
- Loops over integer sequences
- etc.

* Conditionals

You can use the when statement to execute tasks only if certain conditions are met.

 tasks:
   - name: "shutdown Debian flavored systems"
     command: /sbin/shutdown -t now
     when: ansible_os_family == "Debian"


# TODO describe Variables.


* Practical Examples

- Write your own modules
- Jenkins integration (??)
- Ansible Tower
- Wordpress deployment

* Write Your Own Modules

- write the modules in any language you want
- only File I/O is required
- any input parameter is a pair of key=value
- output has to be json or key=value results all on one line

 #!/usr/bin/python

 import datetime
 import json

 date = str(datetime.datetime.now())
 print json.dumps({
     "time" : date
 })

*

In case of a failure

 print json.dumps({
     "failed" : True,
     "msg"    : "failed setting the time"
 })
 sys.exit(1)

In case changes occur while running the module

 print json.dumps({
    "time" : date,
    "changed" : True
 })
 sys.exit(0)

[[http://docs.ansible.com/developing_modules.html]]

* Wordpress Deployment
.image images/wordpress_setup.png 600 700

* Files
 .
 ├── hosts                  # inventory file
 ├── site.yml               # master playbook
 ├── group_vars
 │   └── all                # variables
 └── roles                  # this hierarchy represents a "role"
     ├── common
     │   └── tasks
     │       └── main.yml
     ├── db
     │   ├── handlers
     │   │   └── main.yml   # handlers file (restart database)
     │   ├── tasks
     │   │   └── main.yml   # playbook for 'db' role
     │   └── templates      # files for use with the template resource written in jinja2
     │       └── my.cnf
     ├── lb
     │   └── ...
     └── web
         └── ...

*

 ...
 └── roles
     ├── common
     │   └── ...
     ├── db
     │   └── ...
     ├── lb
     │   ├── handlers
     │   │   └── main.yml
     │   ├── tasks
     │   │   └── main.yml
     │   └── templates
     │       └── default.conf   # nginx configuration file
     └── web
         ├── handlers
         │   └── main.yml
         ├── tasks
         │   └── main.yml
         └── templates
             ├── default.conf   # nginx configuration file
             ├── wordpress.conf # php fastcgi (php-fpm) configuration file
             └── wp-config.php  # wordpress configuration file

* Inventory

hosts

.code vagrant/hosts

group_vars/all

.code vagrant/group_vars/all


* Master Playbook (site.yml)
.code vagrant/site.yml /MySQL/,/- web/
 ...

* Loadbalancer Deployment

.code vagrant/roles/lb/tasks/main.yml /name/,/restart/

.code vagrant/roles/lb/handlers/main.yml /name/,/service/

.code vagrant/roles/lb/templates/default.conf /upstream/,/proxy_pass/

